package com.sergioruy.model.qrcode;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.*;
import java.nio.file.Path;
import java.util.EnumMap;

import com.google.zxing.BarcodeFormat;
import com.google.zxing.EncodeHintType;
import com.google.zxing.WriterException;
import com.google.zxing.qrcode.QRCodeWriter;
import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;
import org.apache.commons.io.FilenameUtils;
import org.json.JSONObject;

import static java.lang.Integer.toHexString;

//TODO refactor this class for english
public final class QrCode {

    /**
     * Payload Format Indicator.
     * Code 00 with static value 01 (mandatory)
     */
    private static final String PFI = "01";

    /**
     * Code for identify the field with the checksum of QRCode generated.
     * @see #crcChecksum(String)
     */
    public static final String COD_CRC = "6304";

    /**
     * Code of country on format ISO3166-1 alpha 2
     */
    private static final String COD_PAIS = "BR";

    /**
     * Currency. "986" = BRL: Real Brasileiro - ISO4217
     */
    private static final String COD_MOEDA = "986";

    /**
     * Specific arrange, Code "00" (GUI) mandatory and static value: br.gov.bcb.pix
     */
    private static final String ARRANJO_PAGAMENTO = "BR.GOV.BCB.PIX";

    /**
     * Merchant Category Code (MCC ISO18245)
     */
    private static final String MCC = "0000";

    /**
     * Code of filed that persist the value of PIX
     */
    private static final String COD_CAMPO_VALOR = "54";

    /**
     * Value for the {@Link #transactionId} when the field not informed.
     */
    private static final String ID_TRANSACAO_VAZIO = "***";

    /**
     * Unic identifier of transaction (max 25 characters).
     * @see #TRANSACTION_ID_EMPTY
     */
    private final String idTransacao;

    private final SendData dadosPix;

    /**
     * The last QRCode generated
     */
    private String code = "";


    public QrCode(final SendData dadosPix) {
        this(dadosPix, ID_TRANSACAO_VAZIO);
    }

    /**
     * Creates a QRCodePix object with a unique transaction ID.
     * @param pixData Data provided by the user for sending the PIX.
     * @param transactionId Unique transaction identifier (max 25 characters). Use *** when omitted.
     *
     * <p>At the launch of PIX, applications were ignoring this field, and even the BRCodes generated in
     * some banking applications did not include this field. However, it was recently identified that some
     * institutions are no longer processing PIX transactions in the absence of this field. See
     * https://github.com/renatomb/php_qrcode_pix/issues/2</p>
     *
     * <p>The content of this field is generated by the PIX receiver. It should be a unique value for each
     * transaction, or *** when not used, as it will then be automatically generated. Given the need for
     * a unique identifier, if there is an option to use it, it is recommended to use a UUID linked to the
     * receiver's system, which will allow for reconciliation of received payments.</p>
     *
     * <p>However, as discussed in the issue https://github.com/bacen/pix-api/issues/214, Bank Itaú blocks
     * any transaction code that has not been previously generated in the institution's application.
     * Therefore, it is necessary to request account manager approval for the receiver's account to generate
     * PIX QR codes outside the bank's application. It is possible that other institutions may adopt this
     * approach in the future.</p>
     *
     * <p>With the use of dynamic QR Codes, it is even possible to define a WebHook where the end customer
     * is automatically notified when a particular transaction is received. Check the details of your
     * institution's API.</p>
     *
     * @see QrCode#QrCode(SendData)
     * @throws IllegalArgumentException when transaction id is invalid
     */
    public QrCode(final SendData dadosPix, final String idTransacao) {
        if(idTransacao.length() > 25) {
            final var msg = "idTransacao deve ter no máximo 25 caracteres. Valor %s tem %d caracteres.".formatted(idTransacao, idTransacao.length());
            throw new IllegalArgumentException(msg);
        }

        this.idTransacao = idTransacao;
        this.dadosPix = dadosPix;
    }

    /**
     * {@return um nome de arquivo PNG temporário} que pode ser usado para
     * {@link #save(Path) salvar} a imagem do QRCode {@link #generate() gerado}.
     * @throws UncheckedIOException se não for possível gerar um nome de arquivo temporário
     */
    static Path tempImgFilePath() {
        try {
            return Path.of(File.createTempFile("qrcode-pix-", ".png").getAbsoluteFile().getPath());
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    /**
     * Cria um objeto JSON contendo os dados completos para gerar o QRCode.
     *
     * @return o objeto JSON criado
     * @see #generate()
     */
    private JSONObject newJSONObject() {
        final var jsonTemplate =
                """
                {
                    '00': '%s',
                    '26': {
                        '00': '%s',
                        '01': '%s',
                        '02': '%s'
                    },
                    '52': '%s',
                    '53': '%s',
                    '%s': '%s',
                    '58': '%s',
                    '59': '%s',
                    '60': '%s',
                    '62': {
                        '05': '%s'
                    }
                }
                """;

        final var json =
                jsonTemplate
                        .formatted(
                                PFI, ARRANJO_PAGAMENTO, dadosPix.key().key(), dadosPix.description(),
                                MCC, COD_MOEDA, COD_CAMPO_VALOR, dadosPix.valueStr(), COD_PAIS,
                                dadosPix.key().name(), dadosPix.originCity(), idTransacao);
        return new JSONObject(json);
    }

    /**
     * Gera o QRCode PIX "Copia e Cola" para os dados informados.
     * @return o código gerado
     * @see #save(Path)
     * @see #toString()
     */
    public String generate() {
        final String partialCode = generateInternal(newJSONObject()) + COD_CRC;
        final String checksum = crcChecksum(partialCode);
        return setCode(partialCode + checksum);
    }

    /**
     * Armazena o último QRCode gerado.
     * @param code QR Code gerado
     * @return
     */
    private String setCode(final String code) {
        this.code = code;
        return code;
    }

    private String generateInternal(final JSONObject jsonObj) {
        final var sb = new StringBuilder();
        jsonObj.keySet().stream().sorted().forEach(key -> {
            final Object val = jsonObj.get(key);
            final String str = encodeValue(key, val);
            sb.append(leftPad(key)).append(strLenLeftPadded(str)).append(str);
        });

        return sb.toString();
    }

    /**
     * Codifica o valor de uma chave do objeto JSON com configurações
     * para geração do QRCode, conforme as especificações do PIX.
     * @param key nome da chave no objeto JSON contendo parte dos dados
     * @param val valor para a chave correspondente no objeto JSON
     * @return o valor da chave codificado
     */
    private String encodeValue(final String key, final Object val) {
        //Se o valor para a chave contém outro objeto, processa seus atributos recursivamente
        if(val instanceof JSONObject jsonObjValue)
            return generateInternal(jsonObjValue);

        //Se o valor é String ou um tipo primitivo
        return key.equals(COD_CAMPO_VALOR) ? val.toString() : removeSpecialChars(val);
    }

    /**
     * Calcula o checksum CRC16 a partir de um código parcial do PIX.
     * @param partialCode código parcial do QRCode
     * @return o checksum em hexadecimal
     */
    private String crcChecksum(final String partialCode){
        int crc = 0xFFFF;
        final var byteArray = partialCode.getBytes();
        for (final byte b : byteArray) {
            crc ^= b << 8;
            for (int i = 0; i < 8; i++) {
                if ((crc & 0x8000) == 0)
                    crc = crc << 1;
                else crc = (crc << 1) ^ 0x1021;
            }
        }

        final int decimal = crc & 0xFFFF;
        return leftPad(toHexString(decimal), 4).toUpperCase();
    }

    private String removeSpecialChars(final Object value) {
        return value.toString().replaceAll("[^a-zA-Z0-9\\-@\\.\\*\\s]", "");
    }

    /**
     * Obtém o total de caracteres de uma String incluindo zero a esquerda se necessário.
     * @return o total como uma String de dois dígitos (incluindo zero à esquerda se necessário).
     * @throws IllegalArgumentException se a quantidade de caracteres do valor é maior que o permitido
     */
    static String strLenLeftPadded(final String value) {
        if (value.length() > 99) {
            final var msg = "Tamanho máximo dos valores dos campos deve ser 99. '%s' tem %d caracteres.".formatted(value, value.length());
            throw new IllegalArgumentException(msg);
        }

        final String len = String.valueOf(value.length());
        return leftPad(len);
    }

    /**
     * Inclui zero à esquerda de um código de um campo do QRCode PIX (se necessário),
     * pois todos os códigos devem ter 2 dígitos.
     * @param code código de um campo do QRCode PIX
     * @return o código com um possível zero à esquerda
     */
    private static String leftPad(final String code) {
        return leftPad(code, 2);
    }

    /**
     * Inclui uma determinada quantidade de zeros à esquerda de um valor.
     * @param code código pra incluir zeros à esquerda
     * @param len tamanho máximo da String retornada
     * @return o código com possíveis zeros à esquerda
     */
    private static String leftPad(final String code, final int len) {
        final var format = "%1$" + len + "s";
        return format.formatted(code).replace(' ', '0');
    }

    /**
     * Salva o QRCode gerado com {@link #generate()}
     * em um arquivo de imagem.
     * Se o código não foi gerado ainda, chama automaticamente o {@link #generate()}.
     * @param imagePath caminho para o arquivo de imagem a ser gerado
     * @see #save()
     * @see #saveAndGetBytes(Path)
     */
    public void save(final Path imagePath) {
        saveAndGetBytes(imagePath);
    }

    /**
     * Salva o QRCode gerado com {@link #generate()} em um arquivo de imagem temporário com nome aleatório.
     * Se o código não foi gerado ainda, chama automaticamente o {@link #generate()}.
     * @see #save(Path)
     * @return o caminho do arquivo gerado
     * @see #saveAndGetBytes(Path)
     */
    public Path save() {
        final Path imagePath = tempImgFilePath();
        saveAndGetBytes(imagePath);
        return imagePath;
    }

    /**
     * Salva o QRCode gerado com {@link #generate()} em um arquivo de imagem.
     * Se o código não foi gerado ainda, chama automaticamente o {@link #generate()}.
     * @param imagePath caminho para o arquivo de imagem a ser gerado
     * @return um vetor de bytes representando a imagem gerada
     * @throws IOException se não for possível acessar o arquivo para gravação
     * @throws WriterException se ocorrer erro durante a gravação de dados no arquivo
     * @see #save(Path)
     * @see #save()
     */
    public byte[] saveAndGetBytes(final Path imagePath) {
        //Obtém a extensão do arquivo
        final var fileFormat = FilenameUtils.getExtension(imagePath.toString());
        if(fileFormat.isEmpty())
            throw new IllegalArgumentException("Nome do arquivo deve conter a extensão para indicar o formato da imagem");

        final var hintsMap = new EnumMap<>(EncodeHintType.class);
        hintsMap.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.L);
        hintsMap.put(EncodeHintType.CHARACTER_SET, "UTF-8");
        final int tamanho = 300; // Tamanho da imagem do QRCode em pixels

        final var writer = new QRCodeWriter();
        try {
            if(code == null || code.isBlank())
                generate();

            final var bitMatrix = writer.encode(code, BarcodeFormat.QR_CODE, tamanho, tamanho, hintsMap);
            final var image = new BufferedImage(tamanho, tamanho, BufferedImage.TYPE_INT_RGB);
            for (int y = 0; y < tamanho; y++) {
                for (int x = 0; x < tamanho; x++) {
                    final var isBlack = bitMatrix.get(x, y);
                    final int color = isBlack ? 0 : 0xFFFFFF; //black or white
                    image.setRGB(x, y, color);
                }
            }

            final var baos = new ByteArrayOutputStream();
            ImageIO.write(image, fileFormat, baos);
            final var byteArray = baos.toByteArray();
            try(final var fos = new FileOutputStream(imagePath.toFile())) {
                fos.write(byteArray);
            }

            return byteArray;
        } catch (IOException | WriterException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * {@return o último QRCode gerado.}
     * @see #generate()
     */
    @Override
    public String toString() {
        return code;
    }
}
